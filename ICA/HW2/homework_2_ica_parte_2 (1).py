# -*- coding: utf-8 -*-
"""Homework 2 - ICA - Parte 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I_bLa9nZA4vYE33LLmttppJ8qGpTkZrq
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import norm
from scipy import stats
from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
from sklearn.linear_model import ElasticNet
from sklearn import metrics
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from math import sqrt
from sklearn.metrics import r2_score

df = pd.read_csv('/content/AB_NYC_2019.csv')

df

# a curva do price_log é mais distribuida do que a do price normal, por isso a mudança

df['price_log'] = np.log(df.price+1)

"""Limpeza dos Dados"""

# tirando colunas que nao serão usadas
df = df.drop(columns=['name','id' ,'host_id','host_name', 
                                   'last_review','price'])

mean = df['reviews_per_month'].mean()
df['reviews_per_month'].fillna(mean, inplace=True)

# nosso previsor no caso será room_type, então analisando aqui quem é o menor incidente

df["room_type"].value_counts()

# retirando o menor incidente -> shared room

df.drop(df.loc[df["room_type"] == 'Shared room'].index, inplace=True)

# copiando room type para colocar na ultima coluna

df["room_types"] = df["room_type"]

# retirando room type da coluna do meio e deixando room_types no final

df.drop(labels = "room_type", axis = 1, inplace = True)

df_x = df.iloc[:,:-1]
df_x

from sklearn.preprocessing import LabelEncoder
X_neighbourhood_group = LabelEncoder()
X_neighbourhood = LabelEncoder()

df_x.iloc[:, 0] = X_neighbourhood_group.fit_transform(df_x.iloc[:, 0])
df_x.iloc[:, 1] = X_neighbourhood.fit_transform(df_x.iloc[:, 1])

df_x

Y_room_types = LabelEncoder()
df.iloc[:, -1] = Y_room_types.fit_transform(df.iloc[:, -1])
df_y = df.iloc[:,-1]
df_y

"""Normalização e Divisão"""

# normalização

scaler = StandardScaler()
df_x = scaler.fit_transform(df_x)

df_x

# divisão -> 70% treino | 30% teste

X_train, X_test, y_train, y_test = train_test_split(df_x, df_y, test_size=0.3, random_state=42)

"""# Logistic Regression"""

from sklearn.linear_model import LogisticRegression

# all parameters not specified are set to their defaults
logisticRegr = LogisticRegression()

logisticRegr.fit(X_train, y_train)

# previsao
predictions = logisticRegr.predict(X_test)

# Use score method to get accuracy of model
score = logisticRegr.score(X_test, y_test)
print(score)

"""Matriz de Confusão"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import metrics
# %matplotlib inline

cm = metrics.confusion_matrix(y_test, predictions)
print(cm)

class_names=[0,1] # name  of classes
fig, ax = plt.subplots()
tick_marks = np.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)
# create heatmap
sns.heatmap(pd.DataFrame(cm), annot=True, cmap="YlGnBu" ,fmt='g')
ax.xaxis.set_label_position("top")
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

print("Accuracy:",metrics.accuracy_score(y_test, predictions))
print("Precision:",metrics.precision_score(y_test, predictions))
print("Recall:",metrics.recall_score(y_test, predictions))

"""ROC"""

predictions_proba = logisticRegr.predict_proba(X_test)[::,1]
fpr, tpr, _ = metrics.roc_curve(y_test,  predictions_proba)
auc = metrics.roc_auc_score(y_test, predictions_proba)
plt.plot(fpr,tpr,label="data 1, auc="+str(auc))
plt.legend(loc=4)
plt.show()